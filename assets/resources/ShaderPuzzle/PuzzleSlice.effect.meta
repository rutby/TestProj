{
  "ver": "1.0.27",
  "uuid": "8301b7e2-ce3f-47dc-b251-c88bc16fb0d5",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_color;\nvarying vec2 v_uv0;\nuniform sampler2D texture;\nuniform vec4 c_shape_type;\nuniform vec2 c_uv0;\nuniform vec2 c_uv1;\nuniform float c_corner_type;\nfloat corner(float r) {\n  float radius = r / 528.;\n  vec2 uv = vec2(v_uv0.x, v_uv0.y);\n  float result0 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(radius + c_uv0.x, radius + c_uv0.y)));\n  float result1 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(c_uv1.x - radius, radius + c_uv0.y)));\n  float result2 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(radius + c_uv0.x, c_uv1.y - radius)));\n  float result3 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(c_uv1.x - radius, c_uv1.y - radius)));\n  float mx0 = 1. - step(radius + c_uv0.x, uv.x);\n  float my0 = 1. - step(radius + c_uv0.y, uv.y);\n  float mx1 = 1. - step(uv.x, c_uv1.x - radius);\n  float my1 = 1. - step(uv.y, c_uv1.y - radius);\n  float lt = result0 * mx0 * my0 * step(c_corner_type, 1. + 0.1) * step(1. - 0.1, c_corner_type);\n  float rt = result1 * mx1 * my0 * step(c_corner_type, 2. + 0.1) * step(2. - 0.1, c_corner_type);\n  float lb = result2 * mx0 * my1 * step(c_corner_type, 4. + 0.1) * step(4. - 0.1, c_corner_type);\n  float rb = result3 * mx1 * my1 * step(c_corner_type, 3. + 0.1) * step(3. - 0.1, c_corner_type);\n  float l0 = step(uv.x, c_uv0.x);\n  float t0 = step(uv.y, c_uv0.y);\n  float r0 = step(c_uv1.x, uv.x);\n  float b0 = step(c_uv1.y, uv.y);\n  return clamp(1. - (lt + rt + lb + rb + l0 + t0 + r0 + b0), 0., 1.);\n}\nvec4 _shape(vec4 o, vec2 pos, float shape, float radius) {\n  float type0 = step(shape, 0. + 0.1) * step(0. - 0.1, shape);\n  float type1 = step(shape, 1. + 0.1) * step(1. - 0.1, shape);\n  float type2 = step(shape, 2. + 0.1) * step(2. - 0.1, shape);\n  float r1 = type1 * smoothstep(radius, radius - 0.005, length(v_uv0 - pos));\n  float r2 = type2 * smoothstep(radius, radius + 0.005, length(v_uv0 - pos));\n  o.a += mix(0., r1, type1);;\n  o.a *= mix(1., r2, type2);\n  o.a = clamp(o.a, 0., 1.);\n  return o;\n}\nvec4 shape(vec4 o, float r) {\n  float radius = r / 528.;\n  vec2 pos0 = vec2(c_uv0.x + 0.334/2., c_uv0.y);\n  vec2 pos1 = vec2(c_uv1.x, c_uv0.y + 0.334/2.);\n  vec2 pos2 = vec2(c_uv0.x + 0.334/2., c_uv1.y);\n  vec2 pos3 = vec2(c_uv0.x, c_uv0.y + 0.334/2.);\n  o = _shape(o, pos0, c_shape_type.x, radius);\n  o = _shape(o, pos1, c_shape_type.y, radius);\n  o = _shape(o, pos2, c_shape_type.z, radius);\n  o = _shape(o, pos3, c_shape_type.w, radius);\n  return o;\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 texture_tmp = texture2D(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  o.a *= corner(13.);\n  o = shape(o, 27.5);\n  float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n  vec4 back = vec4(gray, gray, gray, 0.75);\n  vec4 fore = vec4(o.r, o.g, o.b, 0.25);\n  o.rgb = fore.rgb * 0.25 + back.rgb * 0.75;\n  o *= v_color;\n  gl_FragColor = o.rgba;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin vec2 a_uv0;\nout vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_color;\nin vec2 v_uv0;\nuniform sampler2D texture;\nuniform Custom {\n  vec4 c_shape_type;\n  vec2 c_uv0;\n  vec2 c_uv1;\n  float c_corner_type;\n};\nfloat corner(float r) {\n  float radius = r / 528.;\n  vec2 uv = vec2(v_uv0.x, v_uv0.y);\n  float result0 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(radius + c_uv0.x, radius + c_uv0.y)));\n  float result1 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(c_uv1.x - radius, radius + c_uv0.y)));\n  float result2 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(radius + c_uv0.x, c_uv1.y - radius)));\n  float result3 = 1. - smoothstep(radius, radius-0.0001, length(uv - vec2(c_uv1.x - radius, c_uv1.y - radius)));\n  float mx0 = 1. - step(radius + c_uv0.x, uv.x);\n  float my0 = 1. - step(radius + c_uv0.y, uv.y);\n  float mx1 = 1. - step(uv.x, c_uv1.x - radius);\n  float my1 = 1. - step(uv.y, c_uv1.y - radius);\n  float lt = result0 * mx0 * my0 * step(c_corner_type, 1. + 0.1) * step(1. - 0.1, c_corner_type);\n  float rt = result1 * mx1 * my0 * step(c_corner_type, 2. + 0.1) * step(2. - 0.1, c_corner_type);\n  float lb = result2 * mx0 * my1 * step(c_corner_type, 4. + 0.1) * step(4. - 0.1, c_corner_type);\n  float rb = result3 * mx1 * my1 * step(c_corner_type, 3. + 0.1) * step(3. - 0.1, c_corner_type);\n  float l0 = step(uv.x, c_uv0.x);\n  float t0 = step(uv.y, c_uv0.y);\n  float r0 = step(c_uv1.x, uv.x);\n  float b0 = step(c_uv1.y, uv.y);\n  return clamp(1. - (lt + rt + lb + rb + l0 + t0 + r0 + b0), 0., 1.);\n}\nvec4 _shape(vec4 o, vec2 pos, float shape, float radius) {\n  float type0 = step(shape, 0. + 0.1) * step(0. - 0.1, shape);\n  float type1 = step(shape, 1. + 0.1) * step(1. - 0.1, shape);\n  float type2 = step(shape, 2. + 0.1) * step(2. - 0.1, shape);\n  float r1 = type1 * smoothstep(radius, radius - 0.005, length(v_uv0 - pos));\n  float r2 = type2 * smoothstep(radius, radius + 0.005, length(v_uv0 - pos));\n  o.a += mix(0., r1, type1);;\n  o.a *= mix(1., r2, type2);\n  o.a = clamp(o.a, 0., 1.);\n  return o;\n}\nvec4 shape(vec4 o, float r) {\n  float radius = r / 528.;\n  vec2 pos0 = vec2(c_uv0.x + 0.334/2., c_uv0.y);\n  vec2 pos1 = vec2(c_uv1.x, c_uv0.y + 0.334/2.);\n  vec2 pos2 = vec2(c_uv0.x + 0.334/2., c_uv1.y);\n  vec2 pos3 = vec2(c_uv0.x, c_uv0.y + 0.334/2.);\n  o = _shape(o, pos0, c_shape_type.x, radius);\n  o = _shape(o, pos1, c_shape_type.y, radius);\n  o = _shape(o, pos2, c_shape_type.z, radius);\n  o = _shape(o, pos3, c_shape_type.w, radius);\n  return o;\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 texture_tmp = texture(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  o.a *= corner(13.);\n  o = shape(o, 27.5);\n  float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n  vec4 back = vec4(gray, gray, gray, 0.75);\n  vec4 fore = vec4(o.r, o.g, o.b, 0.25);\n  o.rgb = fore.rgb * 0.25 + back.rgb * 0.75;\n  o *= v_color;\n  gl_FragColor = o.rgba;\n}"
      }
    }
  ],
  "subMetas": {}
}